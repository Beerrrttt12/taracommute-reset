<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>TaraCommute â€“ Reset Password</title>
  <style>
    *{box-sizing:border-box}
    body{font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif;margin:0;background:#f6f7f9;color:#111}
    .wrap{padding:16px}
    .card{max-width:520px;margin:24px auto;padding:24px;background:#fff;border-radius:12px;box-shadow:0 6px 24px rgba(0,0,0,.08)}
    h1{margin:0 0 8px 0;font-size:22px}
    p{margin:8px 0;color:#555}
    .row{margin-top:12px}
    .field{display:flex;align-items:center;gap:8px;border:1px solid #d0d5dd;border-radius:8px;padding:0 8px;background:#fff}
    .field input{flex:1;border:0;outline:0;padding:12px 8px;font-size:16px;background:transparent}
    .icon-btn{border:0;background:transparent;cursor:pointer;color:#374151;padding:8px;visibility:hidden;display:flex;align-items:center}
    .icon-btn.visible{visibility:visible}
    .icon-btn svg{width:18px;height:18px}
    .error-border{border-color:#ef4444}
    button.primary{margin-top:16px;width:100%;padding:12px 14px;border:0;border-radius:8px;background:#16a34a;color:#fff;font-weight:600;font-size:16px;cursor:pointer}
    button.primary[disabled]{opacity:.6;cursor:not-allowed}
    .msg{margin-top:8px;padding:10px 12px;border-radius:8px;font-size:14px}
    .err{background:#fee2e2;color:#991b1b}
    .ok{background:#dcfce7;color:#14532d}
    .muted{color:#6b7280;font-size:12px;margin-top:8px}
    .hide{display:none}
    .hint{display:flex;align-items:center;gap:6px;color:#991b1b;font-size:13px;margin-top:6px}
    .hint .qm{display:inline-flex;align-items:center;justify-content:center;width:18px;height:18px;border-radius:50%;background:#991b1b;color:#fff;font-weight:700;cursor:pointer}
    .tooltip{position:relative}
    .tooltip .bubble{position:absolute;z-index:10;top:26px;left:0;min-width:260px;max-width:480px;background:#111;color:#fff;padding:10px 12px;border-radius:8px;font-size:12px;box-shadow:0 8px 24px rgba(0,0,0,.18)}
    .tooltip .bubble ul{margin:6px 0 0 18px;padding:0}
  </style>
</head>
<body>
  <div class="wrap">
    <div class="card">
      <h1>Reset your password</h1>
      <p>Enter a new password for your TaraCommute account.</p>

      <div id="error" class="msg err hide"></div>
      <div id="ok" class="msg ok hide"></div>

      <div class="row field" id="pwField">
        <input id="password" type="password" placeholder="New password" autocomplete="new-password" />
        <button id="togglePw" class="icon-btn" aria-label="Show/Hide password">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M1 12s4-7 11-7 11 7 11 7-4 7-11 7-11-7-11-7z"/><circle cx="12" cy="12" r="3"/></svg>
        </button>
      </div>

      <div class="row field" id="cfField">
        <input id="confirm" type="password" placeholder="Confirm new password" autocomplete="new-password" />
        <button id="toggleCf" class="icon-btn" aria-label="Show/Hide password">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M1 12s4-7 11-7 11 7 11 7-4 7-11 7-11-7-11-7z"/><circle cx="12" cy="12" r="3"/></svg>
        </button>
      </div>

      <button id="submit" class="primary" disabled>Update Password</button>
      <div class="muted" id="status"></div>
    </div>
  </div>

  <script>
    // CONFIG
    const SUPABASE_URL = 'https://xynxgzkmvehlhtnqubsm.supabase.co';
    const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Inh5bnhnemttdmVobGh0bnF1YnNtIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTc2NDU1NzUsImV4cCI6MjA3MzIyMTU3NX0.1P8xgvLzsHL3nscksnSf8t6azMI8uHAUA4cd_eUQNsY';

    const qs = new URL(window.location.href);
    const hash = qs.hash && qs.hash.startsWith('#') ? qs.hash.slice(1) : '';
    const params = new URLSearchParams(hash);
    let accessToken = params.get('access_token');
    let type = params.get('type');

    const errorEl = document.getElementById('error');
    const okEl = document.getElementById('ok');
    const statusEl = document.getElementById('status');
    const btn = document.getElementById('submit');
    const pw = document.getElementById('password');
    const cf = document.getElementById('confirm');
    const pwField = document.getElementById('pwField');
    const cfField = document.getElementById('cfField');
    const togglePw = document.getElementById('togglePw');
    const toggleCf = document.getElementById('toggleCf');

    let touchedPw = false;
    let touchedCf = false;
    let submitted = false;
    let isVerifying = false;
    let verifiedJwt = null;

    function validPassword(p){
      return p.length >= 8 && /[a-z]/.test(p) && /[A-Z]/.test(p) && /\d/.test(p) && /[^\da-zA-Z]/.test(p);
    }

    // Helpers to normalize and verify tokens (with single-flight & rate-limit handling)
    const looksJwt = (t) => !!t && t.split('.').length === 3;
    async function exchangeVerifyTokenOnce(verifyToken) {
      if (verifiedJwt) return verifiedJwt;
      if (isVerifying) return null; // another exchange is in progress
      isVerifying = true;
      try {
        const res = await fetch(`${SUPABASE_URL}/auth/v1/verify?type=recovery&token=${encodeURIComponent(verifyToken)}`, {
          method: 'POST', headers: { 'apikey': SUPABASE_ANON_KEY, 'Content-Type': 'application/json' }
        });
        const body = await res.json().catch(()=>({}));
        if (res.status === 429) throw new Error('Too many attempts. Wait 60 seconds, then open the newest reset email.');
        if (!res.ok) {
          // Show detailed error for debugging
          const detailedError = `${res.status}: ${body.error_description || body.error || body.msg || 'Unknown error'}`;
          console.error('Verify failed:', detailedError, body);
          throw new Error(`Token verification failed (${detailedError}). Check email template uses {{ .TokenHash }}`);
        }
        verifiedJwt = body?.access_token || body?.accessToken || body?.data?.access_token || null;
        return verifiedJwt;
      } finally {
        isVerifying = false;
      }
    }

    function updateUI(){
      const p = pw.value, c = cf.value;
      const pOk = validPassword(p);
      const match = p.length > 0 && p === c;

      // Eye visibility only when there is input
      togglePw.classList.toggle('visible', p.length > 0);
      toggleCf.classList.toggle('visible', c.length > 0);

      // Field borders only when field has been touched or submitted
      const showPwErr = (touchedPw || submitted) && p.length>0 && !pOk;
      const showCfErr = (touchedCf || submitted) && c.length>0 && !match;
      pwField.classList.toggle('error-border', showPwErr);
      cfField.classList.toggle('error-border', showCfErr);

      // Enable submit based on password validity + match
      const canSubmit = pOk && match;
      btn.disabled = !canSubmit;
    }

    pw.addEventListener('input', updateUI);
    cf.addEventListener('input', updateUI);
    pw.addEventListener('blur', () => { touchedPw = true; updateUI(); });
    cf.addEventListener('blur', () => { touchedCf = true; updateUI(); });

    // Toggle eye (icon only; keep same SVG)
    togglePw.addEventListener('click', () => { pw.type = pw.type === 'password' ? 'text' : 'password'; });
    toggleCf.addEventListener('click', () => { cf.type = cf.type === 'password' ? 'text' : 'password'; });

    // Exchange token if we arrived via /auth/v1/verify?token=... OR the hash has a short access_token (non-JWT)
    (async () => {
      // Case 1: Hash contains a non-JWT access_token (short OTP). Try to exchange it first
      if (accessToken && !looksJwt(accessToken) && (type || 'recovery') === 'recovery') {
        try {
          const jwt = await exchangeVerifyTokenOnce(accessToken);
          if (!jwt) throw new Error('Missing access_token from verification');
          accessToken = jwt;
          const newHash = `#type=recovery&access_token=${encodeURIComponent(accessToken)}`;
          if (location.hash !== newHash) history.replaceState(null, '', newHash);
        } catch(e) {
          errorEl.classList.remove('hide'); errorEl.textContent = e.message || 'Verification failed';
          btn.disabled = true;
        }
      }

      // Case 2: No access token in hash; try exchanging query token
      if (!accessToken) {
        const verifyToken = qs.searchParams.get('token');
        const linkType = qs.searchParams.get('type') || 'recovery';
        if (verifyToken && linkType === 'recovery') {
          try {
            const jwt = await exchangeVerifyTokenOnce(verifyToken);
            accessToken = jwt;
            if (!accessToken) throw new Error('Missing access_token from verification');
            type = 'recovery';
            const newHash = `#type=recovery&access_token=${encodeURIComponent(accessToken)}`;
            if (location.hash !== newHash) history.replaceState(null, '', newHash);
          } catch(e) {
            errorEl.classList.remove('hide'); errorEl.textContent = e.message || 'Verification failed';
            btn.disabled = true;
          }
        }
      }

      // Case 3: No access token yet; token provided in HASH (e.g., ...#type=recovery&token=...)
      if (!accessToken) {
        const hashToken = params.get('token');
        const hashType = params.get('type') || 'recovery';
        if (hashToken && hashType === 'recovery') {
          try {
            const jwt = await exchangeVerifyTokenOnce(hashToken);
            accessToken = jwt;
            if (!accessToken) throw new Error('Missing access_token from verification');
            type = 'recovery';
            const newHash = `#type=recovery&access_token=${encodeURIComponent(accessToken)}`;
            if (location.hash !== newHash) history.replaceState(null, '', newHash);
          } catch(e) {
            errorEl.classList.remove('hide'); errorEl.textContent = e.message || 'Verification failed';
            btn.disabled = true;
          }
        }
      }
      
      // If after all attempts we still don't have a JWT, show clear message and stop
      if (!accessToken || !looksJwt(accessToken)) {
        errorEl.classList.remove('hide');
        errorEl.textContent = 'Invalid or expired reset link. Request a new email and open it immediately.';
        btn.disabled = true;
        return;
      }
      updateUI();
    })();

    async function updatePassword(){
      submitted = true; updateUI();
      if (btn.disabled) return;
      errorEl.classList.add('hide'); okEl.classList.add('hide');

      // Do NOT re-verify here; if we lack a JWT at this point, stop.
      if (!accessToken || !looksJwt(accessToken)) {
        errorEl.classList.remove('hide'); errorEl.textContent = 'This link is no longer valid. Request a new reset email.';
        return;
      }

      try {
        const res = await fetch(`${SUPABASE_URL}/auth/v1/user`, {
          method: 'PUT',
          headers: { 'Content-Type': 'application/json', 'Accept': 'application/json', 'apikey': SUPABASE_ANON_KEY, 'Authorization': `Bearer ${accessToken}` },
          body: JSON.stringify({ password: pw.value.trim() })
        });
        const text = await res.text();
        if (!res.ok){
          let msg = 'Failed to update password.';
          try { const j = JSON.parse(text); msg = j.error_description || j.message || j.error || msg; } catch {}
          throw new Error(`${res.status} ${msg}`);
        }
        okEl.classList.remove('hide'); okEl.textContent = 'Password updated successfully. You can now sign in with your new password.';
      } catch(e){
        errorEl.classList.remove('hide'); errorEl.textContent = e.message || 'Unexpected error.';
      }
    }
    btn.addEventListener('click', updatePassword);

    updateUI();
  </script>
</body>
</html>
