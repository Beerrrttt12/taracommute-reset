<script>
  // CONFIG
  const SUPABASE_URL = 'https://xynxgzkmvehlhtnqubsm.supabase.co';
  const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Inh5bnhnemttdmVobGh0bnF1YnNtIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTc2NDU1NzUsImV4cCI6MjA3MzIyMTU3NX0.1P8xgvLzsHL3nscksnSf8t6azMI8uHAUA4cd_eUQNsY';

  const qs = new URL(window.location.href);
  const hash = qs.hash && qs.hash.startsWith('#') ? qs.hash.slice(1) : '';
  const params = new URLSearchParams(hash);
  let accessToken = params.get('access_token');
  let type = params.get('type');

  const errorEl = document.getElementById('error');
  const okEl = document.getElementById('ok');
  const statusEl = document.getElementById('status');
  const btn = document.getElementById('submit');
  const pw = document.getElementById('password');
  const cf = document.getElementById('confirm');
  const pwField = document.getElementById('pwField');
  const cfField = document.getElementById('cfField');
  const togglePw = document.getElementById('togglePw');
  const toggleCf = document.getElementById('toggleCf');

  let touchedPw = false;
  let touchedCf = false;
  let submitted = false;

  function validPassword(p){
    return p.length >= 8 && /[a-z]/.test(p) && /[A-Z]/.test(p) && /\d/.test(p) && /[^\da-zA-Z]/.test(p);
  }

  function decodeJwt(t) {
    try {
      const b = t.split('.')[1];
      const json = atob(b.replace(/-/g, '+').replace(/_/g, '/'));
      return JSON.parse(json);
    } catch { return null; }
  }

  async function checkToken() {
    if (!accessToken) return { ok: false, msg: 'Missing access_token' };
    const payload = decodeJwt(accessToken);
    if (!payload) return { ok: false, msg: 'Invalid token' };
    const now = Math.floor(Date.now()/1000);
    const minsLeft = Math.max(0, Math.floor((payload.exp - now)/60));
    statusEl.textContent = `Token for ${payload.email || 'user'} exp in ~${minsLeft}m`;

    const res = await fetch(`${SUPABASE_URL}/auth/v1/user`, {
      method: 'GET',
      headers: {
        'apikey': SUPABASE_ANON_KEY,
        'Authorization': `Bearer ${accessToken}`,
        'Accept': 'application/json'
      }
    });
    const text = await res.text();
    if (!res.ok) {
      let msg = 'Token check failed';
      try { const j = JSON.parse(text); msg = j.error_description || j.message || msg; } catch {}
      return { ok: false, msg: `${res.status} ${msg}` };
    }
    return { ok: true, msg: 'Token OK' };
  }

  function updateUI(){
    const p = pw.value, c = cf.value;
    const pOk = validPassword(p);
    const match = p.length > 0 && p === c;

    // Eye visibility only when there is input
    togglePw.classList.toggle('visible', p.length > 0);
    toggleCf.classList.toggle('visible', c.length > 0);

    // Field borders only when field has been touched or submitted
    const showPwErr = (touchedPw || submitted) && p.length>0 && !pOk;
    const showCfErr = (touchedCf || submitted) && c.length>0 && !match;
    pwField.classList.toggle('error-border', showPwErr);
    cfField.classList.toggle('error-border', showCfErr);

    // Enable submit based on password validity + match
    const canSubmit = pOk && match;
    btn.disabled = !canSubmit;
  }

  pw.addEventListener('input', updateUI);
  cf.addEventListener('input', updateUI);
  pw.addEventListener('blur', () => { touchedPw = true; updateUI(); });
  cf.addEventListener('blur', () => { touchedCf = true; updateUI(); });

  // Toggle eye (icon only; keep same SVG)
  togglePw.addEventListener('click', () => { pw.type = pw.type === 'password' ? 'text' : 'password'; });
  toggleCf.addEventListener('click', () => { cf.type = cf.type === 'password' ? 'text' : 'password'; });

  // Exchange token if we arrived via /auth/v1/verify?token=...
  (async () => {
    if (!accessToken) {
      const verifyToken = qs.searchParams.get('token');
      const linkType = qs.searchParams.get('type') || 'recovery';
      if (verifyToken && linkType === 'recovery') {
        try {
          const res = await fetch(`${SUPABASE_URL}/auth/v1/verify?type=recovery&token=${encodeURIComponent(verifyToken)}`, {
            method: 'POST', headers: { 'apikey': SUPABASE_ANON_KEY, 'Content-Type': 'application/json' }
          });
          const body = await res.json().catch(()=>({}));
          if (!res.ok) throw new Error(body.error_description || body.error || 'Failed to verify recovery token');
          accessToken = body?.access_token || body?.accessToken || body?.data?.access_token;
          if (!accessToken) throw new Error('Missing access_token from verification');
          type = 'recovery';
          const newHash = `#type=recovery&access_token=${encodeURIComponent(accessToken)}`;
          if (location.hash !== newHash) location.hash = newHash;
        } catch(e) {
          errorEl.classList.remove('hide'); errorEl.textContent = e.message || 'Verification failed';
          btn.disabled = true;
        }
      }
    }
    const check = await checkToken();
    if (!check.ok) {
      errorEl.classList.remove('hide');
      errorEl.textContent = check.msg;
      btn.disabled = true;
    }
    updateUI();
  })();

  async function updatePassword(){
    submitted = true; updateUI();
    if (btn.disabled) return;
    errorEl.classList.add('hide'); okEl.classList.add('hide');

    // Ensure we have an accessToken; if missing, try to exchange from verify token or hash
    if (!accessToken) {
      const verifyToken = qs.searchParams.get('token') || params.get('token');
      const linkType = qs.searchParams.get('type') || params.get('type') || 'recovery';
      if (verifyToken && linkType === 'recovery') {
        try {
          const res = await fetch(`${SUPABASE_URL}/auth/v1/verify?type=recovery&token=${encodeURIComponent(verifyToken)}`, {
            method: 'POST', headers: { 'apikey': SUPABASE_ANON_KEY, 'Content-Type': 'application/json' }
          });
          const body = await res.json().catch(()=>({}));
          if (!res.ok) throw new Error(body.error_description || body.error || 'Failed to verify recovery token');
          accessToken = body?.access_token || body?.accessToken || body?.data?.access_token;
        } catch(e) {
          errorEl.classList.remove('hide'); errorEl.textContent = e.message || 'Verification failed';
          return;
        }
      }
    }
    if (!accessToken) {
      errorEl.classList.remove('hide'); errorEl.textContent = 'Invalid or expired reset link. Please request a new email.';
      return;
    }

    try {
      const res = await fetch(`${SUPABASE_URL}/auth/v1/user`, {
        method: 'PUT',
        headers: {
          'Content-Type': 'application/json',
          'Accept': 'application/json',
          'apikey': SUPABASE_ANON_KEY,
          'Authorization': `Bearer ${accessToken}`
        },
        body: JSON.stringify({ password: pw.value.trim() })
      });
      const text = await res.text();
      if (!res.ok){
        let msg = 'Failed to update password.';
        try { const j = JSON.parse(text); msg = j.error_description || j.message || j.error || msg; } catch {}
        throw new Error(`${res.status} ${msg}`);
      }
      okEl.classList.remove('hide'); okEl.textContent = 'Password updated successfully. You can now sign in with your new password.';
    } catch(e){
      errorEl.classList.remove('hide'); errorEl.textContent = e.message || 'Unexpected error.';
    }
  }
  btn.addEventListener('click', updatePassword);

  updateUI();
</script>
